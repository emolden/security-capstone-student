# STRIDE Table


---

## Client Trust Boundary

| DFD Element | Type | S | T | R | I | D | E | Threat(s) | Mitigation(s) | Evidence/Test |
|-------------|------|---|---|---|---|---|---|-----------|---------------|---------------|
| Browser (React Client) | Process | ✓ | ✓ | ✓ | ✓ |  | ✓ | **Spoofing:** Malicious code injected into the webpage (cross-site scripting) could pretend to be the user. **Tampering:** Users can open browser developer tools and modify the webpage code or data. **Repudiation:** Any logs kept in the browser can be easily deleted by the user. **Information Disclosure:** Secrets could be visible in the browser's memory, in React's internal state, in browser storage, or accessible to malicious browser extensions. **Elevation:** If permission checks only happen in the browser, users can bypass them using developer tools. | **Spoofing/Tampering:** Validate all user input to prevent malicious code injection. Use security policies that control what scripts can run. **Information Disclosure:** Only send sensitive data to the browser when absolutely necessary. Hide secret values by default. Use secure cookies that JavaScript cannot access. **Denial of Service:** Limit how fast users can make requests to the server. **Elevation**: All permission checks must happen on the server, never trust the browser. | Test by injecting malicious code in input fields. Try modifying webpage using developer tools. Check if secrets are visible when they should be hidden. Test if browser-level permission checks can be bypassed. |


---

## API Trust Boundary

| DFD Element | Type | S | T | R | I | D | E | Threat(s) | Mitigation(s) | Evidence/Test |
|-------------|------|---|---|---|---|---|---|-----------|---------------|---------------|
| API Server | Process | ✓ | ✓ |  | ✓ | ✓ | ✓ | **Spoofing:** Someone could create fake authentication tokens or steal real ones to impersonate users. **Tampering:** Attackers could modify the data being sent to the server in requests.  **Information Disclosure:** Error messages that reveal too much information about how the system works, like showing file paths or database details. **Denial of Service:** Without limits, attackers could overwhelm the server with too many requests. **Elevation:** Attackers could bypass permission checks to access or modify data they shouldn't. | **Spoofing:** Use strong random secrets to sign authentication tokens. Make tokens expire after a short time. **Tampering:** Check all incoming data is valid and expected. **Information Disclosure:** Show generic error messages to users. Turn off debug mode in production. Add security headers. **Denial of Service:** Limit how many requests one user can make. Set maximum request sizes. **Elevation:** Check user permissions on the server for every action. Verify users can only access their own data. | Test with fake authentication tokens. Check if there are limits on requests. Look at error messages to see if they reveal system details. Test if one user can access another user's data. |

---

## API Endpoints - Authentication

| DFD Element | Type | S | T | R | I | D | E | Threat(s) | Mitigation(s) | Evidence/Test |
|-------------|------|---|---|---|---|---|---|-----------|---------------|---------------|
| auth/login | Process | ✓ | | ✓ | ✓ | ✓ | | **Spoofing:** Attackers could try thousands of password combinations automatically (brute force attack). They could use lists of commonly used passwords or stolen password databases from other breaches. Someone could steal a user's password and pretend to be them **Repudiation:** Without logging, can't tell if someone tried to break into an account. **Information Disclosure:** Different error messages for "user doesn't exist" vs "wrong password" tells attackers which usernames are valid. Also, if the server takes longer to check real accounts vs fake ones, attackers can figure out valid usernames. **Denial of Service:** Without limits, attackers could make unlimited login attempts and slow down the server. | **Spoofing:** Require two-factor authentication (password plus phone code). Require strong passwords (mix of uppercase, lowercase, numbers, symbols). Use secure password hashing (bcrypt). Lock accounts after several wrong attempts. Require two-factor authentication (code from phone). **Repudiation:** Log every login attempt, successful or failed, with timestamp and location. **Information Disclosure:** Always show the same error message: "Invalid credentials". Make sure checking passwords takes the same time whether username exists or not. **Denial of Service:** Limit login attempts per user and per IP address. Enable human verification after several failures. | Try logging in with wrong passwords many times. Verify system limits attempts. Check if error messages are different for "wrong username" vs "wrong password". Confirm all login attempts are logged. |
| auth/register | Process | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | **Spoofing:** Bots could create fake accounts automatically. **Tampering:** Attackers could try injecting malicious code in the email or password fields to manipulate the database. **Repudiation:** Without logging, can't track who created accounts. **Information Disclosure:** Error message "Email already exists" lets attackers test which email addresses have accounts in the system. **Denial of Service:** Without limits, attackers could create thousands of fake accounts. **Elevation:** Attackers could try adding an "admin" field to the registration data to give themselves admin privileges. | **Spoofing:** Require email verification (send confirmation link). Enable human verificaiton to prevent bots. Limit the number of registrations in a timeframe. **Tampering:** Validate all input data. Use validation libraries (Zod) to check email format and password rules. Use parameterized database queries (never put user input directly in queries). **Repudiation:** Log all registration attempts. **Information Disclosure:** Use generic messages that don't reveal if email exists. Require email verification before account is active. **Denial of Service:** Limit how many accounts can be created from one IP address. **Elevation:** Always assign user roles on the server. Never trust role information sent by the user. | Try registering with special characters or code in fields. Test if you can add a "role" field to make yourself admin. Check if the system limits how many accounts you can create. Test if "email already exists" error reveals valid emails. |


---

## API Endpoints - Secrets Management

| DFD Element | Type | S | T | R | I | D | E | Threat(s) | Mitigation(s) | Evidence/Test |
|-------------|------|---|---|---|---|---|---|-----------|---------------|---------------|
| GET /items | Process | | | ✓ | ✓ | ✓ | ✓ | Repudiation: System doesn't track who viewed which secrets. Information Disclosure: Returns all secrets in the system to any logged-in user, even secrets they don't own. Secrets are sent in plain text (not encrypted) over the network. Shows too much data including sensitive fields users don't need to see. Denial of Service: Without pagination (breaking results into pages), asking for all secrets at once could use too much memory. Elevation: Any logged-in user can see everyone else's secrets, not just their own. | Repudiation: Log when users access secrets, including which user and which secret. Info Disclosure: Only return secrets that belong to the logged-in user or that have been shared with them. Hide secret values by default (show them masked). Encrypt secrets in the database. Use encrypted connections (HTTPS). DoS: Break large results into pages. Limit how many secrets can be returned at once. Elevation: Filter results - only show secrets the user owns or has permission to see. | Log in as different users and see what secrets each can view. Verify users can only see their own secrets. Check if secret values are hidden by default. Confirm system logs who viewed what. |
| POST /items | Process | | ✓ | ✓ | ✓ | ✓ | ✓ | Tampering: Attackers could try injecting malicious code in the secret name, value, or service fields to manipulate the database. Could insert harmful data. Repudiation: System doesn't log who created which secrets. Information Disclosure: Secrets are stored in plain text in the database instead of being encrypted. Denial of Service: Without limits, users could create thousands of secrets and fill up storage. Elevation: Users could try to create secrets that belong to other users. | Tampering: Validate all input data using validation libraries (Zod). Clean user input to remove dangerous characters. Use parameterized database queries. Limit how long each field can be. Repudiation: Log all secret creation with user details. Info Disclosure: Encrypt secrets before storing them in the database using strong encryption (AES-256). DoS: Limit how many secrets one user can create. Limit how large each secret can be. Elevation: Always set the secret owner on the server based on who's logged in, not based on data from the user. | Try entering special characters or code in secret fields. Try creating many secrets quickly. Verify secrets are encrypted in the database. Test rate limits. Confirm the logged-in user is automatically set as the owner. |
| GET /items/:id | Process | | | ✓ | ✓ | | ✓ | Repudiation: System doesn't log when individual secrets are accessed. Information Disclosure: Users can access any secret by changing the ID number in the URL (called Insecure Direct Object Reference or IDOR). Secret values shown without requiring re-authentication. Elevation: Users can view secrets that belong to other users just by knowing or guessing the ID. | Repudiation: Log every time someone views a secret, including user ID and secret ID. Info Disclosure: Before showing a secret, verify the logged-in user owns it or has been given access. Require users to re-enter their password before revealing sensitive secrets. Use random IDs (UUIDs) instead of sequential numbers so they can't be guessed. Elevation: Check permissions for each secret - verify user owns it or has been granted access. | Try accessing secrets belonging to other users by changing the ID in the URL. Check if you need to re-enter password to reveal secrets. Verify system logs who viewed each secret. |
| POST /items/:id/reveal | Process | | | ✓ | ✓ | | ✓ | Repudiation: System doesn't log when secrets are revealed (unmasked). Information Disclosure: Users can reveal any secret by changing the ID in the URL. No requirement to re-enter password before seeing the actual secret value. Secrets transmitted in plain text over the network. Elevation: Users can reveal secrets belonging to other users. | Repudiation: Log every reveal action prominently. Info Disclosure: Verify user owns the secret before revealing. Require re-entering password before revealing. Use encrypted connections (HTTPS). Consider making revealed secrets disappear after a short time. Elevation: Check ownership before allowing reveal. | Try revealing secrets belonging to other users. Test if you can reveal without re-entering password. Verify audit log captures reveals. |
| POST /items/:id/revoke | Process | | ✓ | ✓ | | ✓ | ✓ | Tampering: Users might try to modify other fields when revoking, not just the status. Repudiation: System doesn't log revocations properly, including who revoked and why. Denial of Service: Someone could revoke many active secrets at once, disrupting service for legitimate users. Elevation: Users can revoke secrets belonging to other users without permission (IDOR). | Tampering: Only allow changing the status field to "revoked". Repudiation: Keep detailed logs of who revoked, when, and optionally why. DoS: Limit how many secrets can be revoked at once. Alert administrators if many secrets are revoked quickly. Elevation: Before allowing revocation, verify user owns the secret or has admin privileges. | Try revoking secrets belonging to other users. Try revoking many secrets quickly. Check if logs capture revocation details. Verify ownership checks. |
| POST /items/:id/rotate | Process | | ✓ | ✓ | ✓ | ✓ | ✓ | Tampering: Users might try to control what the new secret value becomes instead of letting the system generate it. Repudiation: Rotation not logged properly. Information Disclosure: Old secret values kept longer than necessary. Rotation process might expose secrets. Denial of Service: Repeatedly rotating secrets could disrupt systems that use those secrets. Elevation: Users can rotate secrets belonging to other users (IDOR). | Tampering: Generate new secret values on the server, don't let users provide them. Repudiation: Log rotation events with metadata (but not the actual secret values). Info Disclosure: Securely delete old secret values immediately. Encrypt backups. DoS: Limit how often secrets can be rotated. Prevent rapid successive rotations. Elevation: Verify user owns the secret before allowing rotation. | Try rotating secrets belonging to other users. Verify old secrets are deleted. Test rotation rate limits. Check audit logs. |

---

## Database Trust Boundary

| DFD Element | Type | S | T | R | I | D | E | Threat(s) | Mitigation(s) | Evidence/Test |
|-------------|------|---|---|---|---|---|---|-----------|---------------|---------------|
| MongoDB | Data Store | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | Spoofing: Database could be accessed using weak passwords like "admin" or "password123". Someone could bypass authentication completely. Tampering: Malicious code from the API could manipulate database queries (NoSQL injection). Someone could access the database directly and modify data. Repudiation: Database doesn't track who made changes or when. Information Disclosure: Secrets stored in plain text in the database instead of being encrypted. Database user account has more permissions than needed. Database backups not encrypted. Denial of Service: Too many connections to the database. Poorly written queries that take too long to run. Elevation: Database passwords are weak or the same for all environments. Database accounts have admin access when they only need limited access. | Spoofing: Use strong unique passwords for database. Require authentication to connect. Keep database on a private network, not accessible from internet. Tampering: Use parameterized queries that don't allow injection. Give the API user account only the minimum permissions needed. Repudiation: Turn on database audit logging to track all changes. Info Disclosure: Encrypt secrets before storing them in the database. Use encrypted connections (TLS) to the database. Encrypt database backups. DoS: Use connection pooling (reuse connections instead of creating new ones). Set timeouts for queries. Optimize queries with proper database indexes. Elevation: Use role-based access control (give accounts only the permissions they need). Use separate database accounts for different purposes. Never use admin accounts in the application. | Review what permissions the database user has. Try connecting with weak passwords. Check if secrets are encrypted in the database. Verify audit logging is enabled. Test what happens with malicious queries. |

---

## Data Flows

| DFD Element | Type | S | T | R | I | D | E | Threat(s) | Mitigation(s) | Evidence/Test |
|-------------|------|---|---|---|---|---|---|-----------|---------------|---------------|
| User → Browser | Data Flow | ✓ | ✓ | | ✓ | | | Spoofing: Fake websites that look like KeyKeeper trying to steal passwords (phishing). Tampering: Someone intercepting the connection between user and website (man-in-the-middle attack) if not using encrypted connections. Information Disclosure: Someone looking over the user's shoulder while they type passwords or view secrets. Screen recording software. Using KeyKeeper on shared computers where others could see data. | Spoofing: Educate users about phishing. Use clear branding so users can identify the real site. Force encrypted connections (HTTPS). Use HSTS (tells browser to always use HTTPS). Tampering: Only allow encrypted connections (HTTPS). Use secure cookie settings. Use Content Security Policy headers. Info Disclosure: Automatically log users out after inactivity. Show warnings about working on shared computers. Set session timeouts. | Check that the site forces HTTPS. Test HSTS is configured. Try a man-in-the-middle attack in a test environment. |
| Browser → API | Data Flow | ✓ | ✓ | | ✓ | ✓ | ✓ | Spoofing: Authentication tokens stolen and reused by attackers (replay attack). Session hijacking where attackers steal active sessions. Cross-site request forgery where malicious websites trick users' browsers into making requests. Tampering: Attackers modifying request data or headers before it reaches the server. Man-in-the-middle attacks intercepting and changing requests. Information Disclosure: Authentication tokens visible in URLs (which get logged and cached). Unencrypted connections allowing anyone on the network to see data. Secrets sent in requests visible to network sniffers. Denial of Service: Flooding the server with too many requests. Sending huge requests that overwhelm the server. Elevation: Modified authentication headers to claim higher privileges. Modified tokens with admin roles. | Spoofing: Use HTTP-only cookies (JavaScript cannot access them) for authentication tokens. Use SameSite cookie settings. Use CSRF tokens to validate requests came from your site. Make tokens expire quickly. Tampering: Only accept encrypted connections (HTTPS/TLS). Verify requests haven't been modified. Configure CORS properly. Info Disclosure: Always use HTTPS. Use HSTS. Never put authentication tokens in URLs, only in cookies or headers. DoS: Limit how many requests one user or IP can make. Limit how large requests can be. Elevation: Verify authentication tokens on the server. Check the token signature and claims match what's expected. | Test if cookies are HTTP-only. Try replaying old authentication tokens. Check if HTTPS is enforced. Test rate limiting. Verify CSRF protection. |
| API → Database | Data Flow | ✓ | ✓ | | ✓ | ✓ | ✓ | Spoofing: Database connection credentials (username/password) stolen from environment variables or code. Tampering: Malicious database queries if user input is put directly in queries instead of using parameterized queries. Unauthorized direct access to database bypassing the API. Information Disclosure: Secrets sent in plain text over the network to the database if not using encrypted connections. Database connection strings (which contain passwords) logged or exposed in error messages. Denial of Service: Poorly written queries that use too much database processing power. Too many connections to database exhausting available connections. Elevation: Database passwords compromised. Using admin database accounts for routine operations when lower-privilege accounts would work. | Spoofing: Store database connection credentials securely in environment variables or secrets management systems, not in code. Keep database on private network not accessible from internet. Tampering: Always use parameterized queries that don't allow injection. Use network segmentation to isolate database. Use database firewall rules. Info Disclosure: Use encrypted connections (TLS/SSL) to the database. Never log database passwords or connection strings. DoS: Use connection pooling (reuse connections). Set timeouts for queries so long-running queries get cancelled. Elevation: Use principle of least privilege - give the API user only the minimum database permissions needed. Use separate database accounts for development and production. | Review database connection configuration. Check that TLS is enabled. Try connecting with expired credentials. Review where connection strings are stored. |

Legend: S=Spoofing, T=Tampering, R=Repudiation, I=Info Disclosure, D=DoS, E=Elevation
