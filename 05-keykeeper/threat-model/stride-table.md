# STRIDE Table


---

## Client Trust Boundary

| DFD Element | Type | S | T | R | I | D | E | Threat(s) | Mitigation(s) | Evidence/Test |
|-------------|------|---|---|---|---|---|---|-----------|---------------|---------------|
| Browser (React Client) | Process | ✓ | ✓ | ✓ | ✓ |  | ✓ | **Spoofing:** Malicious code injected into the webpage (cross-site scripting) could pretend to be the user. **Tampering:** Users can open browser developer tools and modify the webpage code or data. **Repudiation:** Any logs kept in the browser can be easily deleted by the user. **Information Disclosure:** Secrets could be visible in the browser's memory, in React's internal state, in browser storage, or accessible to malicious browser extensions. **Elevation:** If permission checks only happen in the browser, users can bypass them using developer tools. | **Spoofing/Tampering:** Validate all user input to prevent malicious code injection. Use security policies that control what scripts can run. **Information Disclosure:** Only send sensitive data to the browser when absolutely necessary. Hide secret values by default. Use secure cookies that JavaScript cannot access. **Denial of Service:** Limit how fast users can make requests to the server. **Elevation**: All permission checks must happen on the server, never trust the browser. | Test by injecting malicious code in input fields. Try modifying webpage using developer tools. Check if secrets are visible when they should be hidden. Test if browser-level permission checks can be bypassed. |


---

## API Trust Boundary

| DFD Element | Type | S | T | R | I | D | E | Threat(s) | Mitigation(s) | Evidence/Test |
|-------------|------|---|---|---|---|---|---|-----------|---------------|---------------|
| API Server | Process | ✓ | ✓ |  | ✓ | ✓ | ✓ | **Spoofing:** Someone could create fake authentication tokens or steal real ones to impersonate users. **Tampering:** Attackers could modify the data being sent to the server in requests.  **Information Disclosure:** Error messages that reveal too much information about how the system works, like showing file paths or database details. **Denial of Service:** Without limits, attackers could overwhelm the server with too many requests. **Elevation:** Attackers could bypass permission checks to access or modify data they shouldn't. | **Spoofing:** Use strong random secrets to sign authentication tokens. Make tokens expire after a short time. **Tampering:** Check all incoming data is valid and expected. **Information Disclosure:** Show generic error messages to users. Turn off debug mode in production. Add security headers. **Denial of Service:** Limit how many requests one user can make. Set maximum request sizes. **Elevation:** Check user permissions on the server for every action. Verify users can only access their own data. | Test with fake authentication tokens. Check if there are limits on requests. Look at error messages to see if they reveal system details. Test if one user can access another user's data. |

---

## API Endpoints - Authentication

| DFD Element | Type | S | T | R | I | D | E | Threat(s) | Mitigation(s) | Evidence/Test |
|-------------|------|---|---|---|---|---|---|-----------|---------------|---------------|
| auth/login | Process | ✓ | | ✓ | ✓ | ✓ | | **Spoofing:** Attackers could try thousands of password combinations automatically (brute force attack). They could use lists of commonly used passwords or stolen password databases from other breaches. Someone could steal a user's password and pretend to be them **Repudiation:** Without logging, can't tell if someone tried to break into an account. **Information Disclosure:** Different error messages for "user doesn't exist" vs "wrong password" tells attackers which usernames are valid. Also, if the server takes longer to check real accounts vs fake ones, attackers can figure out valid usernames. **Denial of Service:** Without limits, attackers could make unlimited login attempts and slow down the server. | **Spoofing:** Require two-factor authentication (password plus phone code). Require strong passwords (mix of uppercase, lowercase, numbers, symbols). Use secure password hashing (bcrypt). Lock accounts after several wrong attempts. Require two-factor authentication (code from phone). **Repudiation:** Log every login attempt, successful or failed, with timestamp and location. **Information Disclosure:** Always show the same error message: "Invalid credentials". Make sure checking passwords takes the same time whether username exists or not. **Denial of Service:** Limit login attempts per user and per IP address. Enable human verification after several failures. | Try logging in with wrong passwords many times. Verify system limits attempts. Check if error messages are different for "wrong username" vs "wrong password". Confirm all login attempts are logged. |
| auth/register | Process | ✓ | ✓ | ✓ | ✓ | ✓ | ✓ | **Spoofing:** Bots could create fake accounts automatically. **Tampering:** Attackers could try injecting malicious code in the email or password fields to manipulate the database. **Repudiation:** Without logging, can't track who created accounts. **Information Disclosure:** Error message "Email already exists" lets attackers test which email addresses have accounts in the system. **Denial of Service:** Without limits, attackers could create thousands of fake accounts. **Elevation:** Attackers could try adding an "admin" field to the registration data to give themselves admin privileges. | **Spoofing:** Require email verification (send confirmation link). Enable human verificaiton to prevent bots. Limit the number of registrations in a timeframe. **Tampering:** Validate all input data. Use validation libraries (Zod) to check email format and password rules. Use parameterized database queries (never put user input directly in queries). **Repudiation:** Log all registration attempts. **Information Disclosure:** Use generic messages that don't reveal if email exists. Require email verification before account is active. **Denial of Service:** Limit how many accounts can be created from one IP address. **Elevation:** Always assign user roles on the server. Never trust role information sent by the user. | Try registering with special characters or code in fields. Test if you can add a "role" field to make yourself admin. Check if the system limits how many accounts you can create. Test if "email already exists" error reveals valid emails. |


---

## API Endpoints - Secrets Management

| DFD Element | Type | S | T | R | I | D | E | Threat(s) | Mitigation(s) | Evidence/Test |
|-------------|------|---|---|---|---|---|---|-----------|---------------|---------------|
| GET /items | Process |  | |  | ✓ |  | ✓ | **Information Disclosure/Elevation:** The user should only be able to view the secrets they are authorized to see.|  **Info Disclosure/Elevation::** Only return secrets that belong to the logged-in user or that have been shared with them. Hide secret values by default (show them masked). Encrypt secrets in the database. Use encrypted connections (HTTPS).| Log in as different users and see what secrets each can view. Verify users can only see their own secrets. Check if secret values are hidden by default. Confirm system logs who viewed what. |
| POST /items | Process | | ✓ | ✓ | ✓ | ✓ | ✓ | **Tampering:** Attackers could try injecting malicious code in the secret name, value, or service fields to manipulate the database. Could insert harmful data. **Repudiation:** System doesn't log who created which secrets. **Information Disclosure:** Secrets are stored in plain text in the database instead of being encrypted. **Denial of Service:** Without limits, users could create thousands of secrets and fill up storage. **Elevation:** Users could try to create secrets that belong to other users. | **Tampering:** Validate all input data. Clean user input to remove dangerous characters. Use parameterized database queries. Limit how long each field can be. **Repudiation:** Log all secret creation with user details. **Information Disclosure:** Encrypt secrets before storing them in the database using strong encryption.(Symmetrical) **Denial of Service:** Limit how many secrets one user can create. Limit how large each secret can be. **Elevation:** Always set the secret owner on the server based on who's logged in, not based on data from the user. | Try entering special characters or code in secret fields. Try creating many secrets quickly. Verify secrets are encrypted in the database. Test rate limits. Confirm the logged-in user is automatically set as the owner. |
| items/:id/reveal | Process | | | ✓ | ✓ | | ✓ | **Repudiation:** System doesn't log when secrets are revealed (unmasked). **Information Disclosure:** Users can reveal any secret by changing the ID in the URL. No requirement to re-enter password before seeing the actual secret value. Secrets transmitted in plain text over the network. **Elevation:** Users can reveal secrets belonging to other users. | **Repudiation:** Log every reveal action prominently. **Info Disclosure:** Verify user owns the secret before revealing. Require re-entering password before revealing. Use encrypted connections (HTTPS). Consider making revealed secrets disappear after a short time. **Elevation:** Check ownership before allowing reveal. | Try revealing secrets belonging to other users. Test if you can reveal without re-entering password. Verify audit log captures reveals. |
| items/:id/revoke | Process | |  | ✓ | | ✓ | ✓ |  **Repudiation:** System doesn't log revocations properly, including who revoked and why. **Denial of Service:** Someone could revoke many active secrets at once, disrupting service for legitimate users. **Elevation:** Users can revoke secrets belonging to other users without permission (IDOR). | Repudiation: Keep detailed logs of who revoked, when, and optionally why. DoS: Limit how many secrets can be revoked at once. Alert administrators if many secrets are revoked quickly. Elevation: Before allowing revocation, verify user owns the secret or has admin privileges. | Try revoking secrets belonging to other users. Try revoking many secrets quickly. Check if logs capture revocation details. Verify ownership checks. ||

---

## Database Trust Boundary

| DFD Element | Type | S | T | R | I | D | E | Threat(s) | Mitigation(s) | Evidence/Test |
|-------------|------|---|---|---|---|---|---|-----------|---------------|---------------|
| MongoDB | Data Store |  | ✓ | ✓ | ✓ | ✓ | ✓ |  **Tampering:** Malicious code from the API could manipulate database queries (NoSQL injection). Someone could access the database directly and modify data. **Repudiation:** Database doesn't track who made changes or when. **Information Disclosure:** Secrets stored in plain text in the database instead of being encrypted. Database user account has more permissions than needed. **Denial of Service:** Overloading with queries that take too long to run. **Elevation:** Database passwords are weak or the same for all environments. Database accounts have admin access when they only need limited access. | **Tampering:** Use parameterized queries that don't allow injection. Give the API user account only the minimum permissions needed. **Repudiation:** Track all changes. **Information Disclosure:** Encrypt secrets before storing them in the database. Use encrypted connections (TLS) to the database. Encrypt database backups. **Denial of Service:** Use connection pooling (reuse connections instead of creating new ones). Set timeouts for queries. Optimize queries with proper database indexes. **Elevation:** Use role-based access control (give accounts only the permissions they need). Use separate database accounts for different purposes (secrets separate from logs). | Review what permissions the database user has. Try connecting with weak passwords. Check if secrets are encrypted in the database. Verify all logging is enabled. Test what happens with malicious queries. |

---


Legend: S=Spoofing, T=Tampering, R=Repudiation, I=Info Disclosure, D=DoS, E=Elevation
